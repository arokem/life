function fe = feConnectomeBuildModel(fe,zeroMean)
% Compute matrix to predict directional diffusion in each voxel from fibers
%
%   fe = feConnectomeBuildModel(fe,zeroMean)
%
% INPUTS: fe -  An fe structure, see feCreate.m
%         zeroMean - Remote the mean of the prediction (default = true).
%
% See also: feFitModel.m, feComputePredictedSignal.m
%
% Example:  
%
% Copyright (2013-2014), Franco Pestilli, Stanford University, pestillifranco@gmail.com.
%
% -- The LiFE Model --
%
% LiFE stands for Linear Fascicle Evaluation. The quality of a white-matter
% connectome is evaluated by using the connectome to model the diffusion
% signal in the volume of the connectome.
%
% The LiFE model is set up in the following way. The diffusion signal in
% the voxels comprising the volume of the connectome is modelled as a
% linear equation of the following form:
%
%   dSig = [M Miso] * w
%
% Where dSig is a nVoxels * nBvecs x 1 vector containing the predicted
% diffusion signal in each voxel and each diffusion direction measured. M
% is a block matrix that has the following shape:
%
%   M = [fiber_component, isotropic_component]
%
% Where fiber_component is a nVoxels * nBvecs x nFibers matrix containing
% the contribution of each fiber to the diffusion signal in each voxel and
% direction. This matrix is sparse, because if a fiber does not pass
% through a voxel, the contribution in that combination is set to 0. The
% isotropic_component accounts for the part of the diffusion signal that is
% not generated by the fiber, but rather by other elements of the tissue in
% that voxel and freely diffusing water.
%
% The fiber_component is the *sum* over contributions from individual unique
% fibers in the voxel. The isotropic_component is simply the mean diffusion
% signal over all directions in the voxel (assumed to be spherical in
% shape...).
%
% When a fiber passes through a voxel, the element of M at (voxel * bvec, fiber)
% will contain the following the predicted diffusion signal as follows:
%
%   S = S0 exp(-bval*(bvec*Q*bvec))
%
% Where Q is the quadratic form of the tensor and S0 is the diffusion
% signal measured with no diffusion weighting (baseline measured in B0
% scans).
%
% M is represented as a Matlab 'sparse' matrix. This saves memory and
% speeds up calculations. However, it makes the computations required in
% building the matrix a little strange.

if notDefined('fe'),  error('LiFE (fe = feCreate) struct needed'); end
if notDefined('zeroMean'), zeroMean = true; end

disp('LiFE - Building the connectome model...');
tic
% Indexes of actually used voxels, this can be less than the number of
% voxels int he ROI in case some voxels have no fibers in them
usedVoxels   = feGet(fe,'usedVoxels');
nVoxels      = length(usedVoxels);
nBvecs       = feGet(fe,'nBvecs');
vox_sparse_pSig = cell(nVoxels,1);

% Generate the signal predicted in each voxel by the connectome.
%
% This for-loop is written in such a way that matlab (ver later than 7.9)
% will run it in parallel if parallel processing is allowed.
fprintf('LiFE - Predicting diffusion signal in %i voxel...\n',nVoxels);

feOpenLocalCluster
parfor vv = 1:nVoxels
  num_unique_fibers = feGet(fe,'unique f num',usedVoxels(vv));
  
  % This returns a matrix that is size nBvecs x num_unique_fibers 
  voxelPSignal      = feComputeVoxelSignal(fe,usedVoxels(vv));
  
  % Fibers in the connectome determine the directional signal in the voxel
  % signal, not the mean signal in the voxel. Typically, we demean the
  % voxel signal we will predict.
  %
  %  demeaned_pSig = voxelPSignal - repmat(mean(voxelPSignal, 1),nBvecs,1);
  %
  % The mean is predicted by the Miso part of the matrix, not the
  % Mfiber part.
  %
  % Then we reorganize the demeaned signal into a column vector
  %
  %  vox_sparse_pSig{vv} = reshape(demeaned_pSig', num_unique_fibers * nBvecs, 1) ;
  %
  % Somehow this column vector ends up occupying the right parts of the
  % Mfiber matrix when we are done.  That miracle happens below.
  if zeroMean
      % In typical application, we remove the mean from the fiber
      % predictions.  The returned prediction has zero mean.
      vox_sparse_pSig{vv}   = reshape((voxelPSignal - repmat(mean(voxelPSignal, 1),nBvecs,1))', ...
          num_unique_fibers * nBvecs, 1) ;
  else
      % Do not remove the mean

      % For other purposes, we want to retain the fiber mean.
      % These cases have to do with building simulated
      % data set.
      vox_sparse_pSig{vv}   = reshape((voxelPSignal)', num_unique_fibers * nBvecs, 1) ;
  end
  
end
fprintf('LiFE - Prediction computed in: %2.3fs.\n',toc);

tic
fprintf('LiFE - Allocating the model prediction...')

% These variables will be used to generate the sparse matrix indices and
% values (from the dw signal in each voxel-direction). We pre-allocate here
% for speed. We assign the values in the loop below.  More explanation
% follows.

% Each row and column of the Mfiber matrix represents a unique contribution
% to the signal in some voxel (group of rows) from a fiber (column).  The
% total number of elements of Mfiber is the number of unique fibers
% (columns), times the number of voxels, times the number of directions
% (rows).
nUniqueFibersInEachVoxel = feGet(fe,'unique f num');

% number of non-zero elements in the MFiber matrix
M_siz  = sum(nUniqueFibersInEachVoxel(1:nVoxels))*nBvecs;

% This is a vector that will contain the diffusion signals
M_signal = zeros(M_siz, 1);

% These define the row/col entry in the Mfiber matrix where the diffusion
% signal needs to be stored.
M_rows   = zeros(M_siz, 1);
M_cols   = zeros(M_siz, 1);

% Now, pre-allocate space for the measured diffusion signal.  This will be
% filled up in the following loop, too.
fe       = feSet(fe,'dSig measured',zeros(1,nVoxels*nBvecs));

% This is the slowest part of the computation.
% The following lines create the *sparse-matrix* indexing into the M matrix.
% Plus generate a vector of measured signal, full signal and demeaned.
%
% The following operations cannot be run in parallel because we address
% vectors and matrices on the fly.
end_idx = 0;
for vv = 1:nVoxels
  num_unique_fibers   = feGet(fe,'unique f num',usedVoxels(vv));
  index_unique_fibers = cell2mat(feGet(fe,'unique f',usedVoxels(vv)));

  % The first return is a binary vector of the locations of the rows of
  % Mfiber corresponding to the current voxel.  We do the find to get the
  % indices of these rows.
  dense_rows  = find(feGet(fe,'voxel rows',vv));
  
  % We determine the column/row combinations for the non-zero elements in
  % the part of M corresponding to the current voxel:
  sparse_rows = kron(dense_rows,ones(num_unique_fibers,1));
  sparse_cols = repmat(index_unique_fibers, nBvecs, 1);

  % We need to assign the sparse_* variables into the pre-allocated M_*
  % variables in the right place. 
  start_idx = end_idx + 1;
  end_idx   = end_idx + length(sparse_rows);
  
  M_rows(start_idx:end_idx)   = sparse_rows;
  M_cols(start_idx:end_idx)   = sparse_cols;
  M_signal(start_idx:end_idx) = vox_sparse_pSig{vv};
  
  % Reorganize the diffusion data for each voxel into a long vector: 
  % nDirs X nVoxels.
  fe.life.dSig(dense_rows) = feGet(fe,'diffusion signal in voxel',usedVoxels(vv));
end

% Install the matrix in the fe structure.
fe = feSet(fe,'Mfiber',sparse(M_rows, M_cols, M_signal));

fprintf('process completed in %2.3fs.\n',toc)
disp('LiFE - DONE Building the connectome model.');

return
